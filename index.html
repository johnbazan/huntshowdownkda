<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <title>Hunt Stats Tracker</title>
  
  
  <style>
    :root{
      --bg0:#05060d;
      --bg1:#0b1022;
      --bg2:#151d3b;
      --surface: rgba(10,16,34,.74);
      --surface-2: rgba(7,12,26,.82);
      --stroke: rgba(106,181,255,.24);
      --stroke-soft: rgba(106,181,255,.12);
      --text: rgba(236,245,255,.95);
      --muted: rgba(184,209,238,.74);
      --accent:#4ed5ff;
      --accent-2:#6d7bff;
      --good:#4be39d;
      --bad:#ff5f85;
      --radius:20px;
      --radius2:14px;
      --shadow: 0 24px 60px rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    html{ color-scheme: dark; }

    body{
      margin:0;
      min-height:100vh;
      padding:24px;
      color:var(--text);
      font-family: "Space Grotesk", ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      background:
        radial-gradient(1200px 680px at 10% -10%, rgba(78,213,255,.14), transparent 62%),
        radial-gradient(1100px 620px at 90% 8%, rgba(109,123,255,.17), transparent 60%),
        radial-gradient(800px 600px at 50% 115%, rgba(13,187,141,.14), transparent 72%),
        linear-gradient(180deg, var(--bg2), var(--bg0));
      background-attachment: fixed;
      position:relative;
      overflow-x:hidden;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        linear-gradient(115deg, rgba(255,255,255,.03), transparent 24%),
        repeating-linear-gradient(90deg, rgba(255,255,255,.016) 0 1px, transparent 1px 62px);
      opacity:.5;
      z-index:0;
    }

    .wrap{ width:100%; max-width:none; margin:0 auto; position:relative; z-index:1; }

    header{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom:16px;
      padding:18px;
      border-radius:var(--radius);
      border:1px solid var(--stroke);
      background:
        linear-gradient(140deg, rgba(78,213,255,.08), transparent 46%),
        linear-gradient(220deg, rgba(109,123,255,.10), transparent 40%),
        var(--surface);
      box-shadow:var(--shadow);
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width:860px;
    }

    h1{
      margin:0;
      font-family: "Orbitron", "Space Grotesk", sans-serif;
      font-size: clamp(24px, 3.5vw, 42px);
      letter-spacing: 1.8px;
      text-transform: uppercase;
      line-height:1.05;
      text-shadow: 0 0 18px rgba(78,213,255,.25);
    }

    .subtitle{
      margin:0;
      color:var(--muted);
      line-height:1.5;
      font-size:14px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:9px;
      padding:9px 12px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background:rgba(10,16,34,.55);
      color:var(--muted);
      font-size:12px;
      backdrop-filter: blur(5px);
    }

    .dot{
      width:10px;
      height:10px;
      border-radius:999px;
      background:var(--accent);
      box-shadow:0 0 0 4px rgba(78,213,255,.16), 0 0 16px rgba(78,213,255,.3);
    }
    .dot.ok{
      background:var(--good);
      box-shadow:0 0 0 4px rgba(75,227,157,.16), 0 0 16px rgba(75,227,157,.28);
    }
    .dot.bad{
      background:var(--bad);
      box-shadow:0 0 0 4px rgba(255,95,133,.14), 0 0 16px rgba(255,95,133,.28);
    }

    .grid{
      display:grid;
      grid-template-columns:1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width:1000px){
      .grid{ grid-template-columns:1fr; }
      header{ flex-direction:column; }
    }

    .card{
      position:relative;
      border-radius:var(--radius);
      border:1px solid var(--stroke);
      background:
        linear-gradient(155deg, rgba(78,213,255,.08), transparent 42%),
        linear-gradient(215deg, rgba(109,123,255,.10), transparent 40%),
        var(--surface-2);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .card::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius:var(--radius);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.04),
        inset 0 -70px 120px rgba(0,0,0,.3);
    }

    .card .head{
      padding:14px 16px 11px;
      border-bottom:1px solid var(--stroke-soft);
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
      background:rgba(0,0,0,.15);
    }

    .card .title{
      font-family: "Orbitron", "Space Grotesk", sans-serif;
      font-size:12px;
      letter-spacing:1.2px;
      text-transform:uppercase;
      color:rgba(230,242,255,.96);
      font-weight:700;
    }

    .card .body{
      padding:16px;
      position:relative;
      z-index:1;
    }

    .drop{
      border:2px dashed var(--stroke);
      border-radius:var(--radius2);
      padding:16px;
      background:rgba(8,14,28,.56);
      outline:none;
      transition:border-color .18s ease, box-shadow .18s ease, background .18s ease;
    }

    .drop:focus{
      border-color:rgba(78,213,255,.8);
      background:rgba(8,14,28,.76);
      box-shadow:0 0 0 5px rgba(78,213,255,.16);
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:12px;
    }

    button{
      padding:10px 13px;
      border-radius:10px;
      border:1px solid var(--stroke);
      background:
        linear-gradient(180deg, rgba(78,213,255,.15), rgba(10,16,34,.54));
      color:var(--text);
      cursor:pointer;
      letter-spacing:.2px;
      transition: transform .14s ease, box-shadow .14s ease, border-color .14s ease;
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
    }

    button:hover{
      transform:translateY(-1px);
      border-color:rgba(78,213,255,.55);
      box-shadow:0 12px 24px rgba(0,0,0,.42), 0 0 0 3px rgba(78,213,255,.14);
    }

    button:active{ transform:translateY(0); }
    button:disabled{
      opacity:.46;
      cursor:not-allowed;
      transform:none;
      box-shadow:none;
    }

    .hint{
      color:var(--muted);
      margin:10px 0 0;
      line-height:1.5;
    }

    .preview{
      margin-top:12px;
      border-radius:var(--radius2);
      border:1px solid var(--stroke-soft);
      overflow:hidden;
      background:rgba(0,0,0,.24);
    }
    .preview img{
      display:block;
      width:100%;
      max-height:380px;
      object-fit:contain;
    }

    .kpis{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:12px;
    }
    @media (max-width:560px){ .kpis{ grid-template-columns:1fr; } }

    .kpi{
      background:
        linear-gradient(160deg, rgba(78,213,255,.10), transparent 42%),
        linear-gradient(220deg, rgba(109,123,255,.12), transparent 45%),
        rgba(10,16,34,.62);
      border:1px solid var(--stroke-soft);
      border-radius:var(--radius2);
      padding:14px;
      min-height:154px;
      position:relative;
      overflow:hidden;
    }

    .kpi .label{
      color:rgba(198,222,246,.8);
      font-size:11px;
      letter-spacing:1px;
      text-transform:uppercase;
      font-family: "Orbitron", "Space Grotesk", sans-serif;
    }

    .kpi .value{
      font-size:42px;
      font-weight:900;
      line-height:1;
      margin-top:8px;
      font-family: "Orbitron", "Space Grotesk", sans-serif;
    }

    .kpi .sub{
      margin-top:6px;
      color:var(--muted);
      font-size:13px;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      margin-top:10px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--stroke-soft);
      background:rgba(7,12,26,.74);
      color:var(--muted);
      font-size:12px;
    }

    .badge .mini{
      width:8px;
      height:8px;
      border-radius:999px;
      background:var(--accent);
      box-shadow:0 0 0 4px rgba(78,213,255,.16);
    }
    .badge .mini.ok{
      background:var(--good);
      box-shadow:0 0 0 4px rgba(75,227,157,.14);
    }
    .badge .mini.bad{
      background:var(--bad);
      box-shadow:0 0 0 4px rgba(255,95,133,.14);
    }

    .meter{
      margin-top:10px;
      padding:10px 10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke-soft);
      background:rgba(8,14,28,.64);
    }

    .meterTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.3;
      margin-bottom:8px;
    }
    .meterTop b{
      color:rgba(230,242,255,.96);
      letter-spacing:.5px;
    }

    .progress{
      width:100%;
      height:13px;
      border-radius:999px;
      overflow:hidden;
      border:1px solid var(--stroke-soft);
      background:rgba(0,0,0,.35);
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.34);
    }

    .bar{
      width:0%;
      height:100%;
      border-radius:999px;
      transition:width .22s ease;
      background:linear-gradient(90deg, var(--accent), var(--accent-2));
      box-shadow:0 0 20px rgba(109,123,255,.4);
      position:relative;
    }

    .bar::after{
      content:"";
      position:absolute;
      inset:0;
      background:repeating-linear-gradient(130deg, rgba(255,255,255,.18) 0 7px, transparent 7px 14px);
      opacity:.25;
    }

    .chartsGrid{
      display:grid;
      grid-template-columns:repeat(3,minmax(0,1fr));
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:1040px){ .chartsGrid{ grid-template-columns:repeat(2,minmax(0,1fr)); } }
    @media (max-width:760px){ .chartsGrid{ grid-template-columns:1fr; } }

    .chartPanel{
      border:1px solid var(--stroke-soft);
      border-radius:var(--radius2);
      background:
        linear-gradient(160deg, rgba(78,213,255,.12), transparent 48%),
        linear-gradient(220deg, rgba(109,123,255,.14), transparent 56%),
        rgba(8,14,28,.72);
      padding:10px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
    }

    .chartTitle{
      font-family: "Orbitron", "Space Grotesk", sans-serif;
      text-transform:uppercase;
      letter-spacing:.9px;
      font-size:11px;
      color:rgba(200,224,248,.84);
      margin-bottom:8px;
    }

    .chartWrap{
      height:190px;
      max-height:190px;
      width:100%;
      position:relative;
      overflow:hidden;
      border-radius:12px;
      border:1px solid var(--stroke-soft);
      background:rgba(0,0,0,.24);
    }

    .chartPanel.chartWide{
      grid-column: span 2;
    }
    @media (max-width:760px){
      .chartPanel.chartWide{
        grid-column: auto;
      }
    }

    .chartWrap canvas{
      display:block;
      width:100% !important;
      height:100% !important;
    }

    .chartBox{
      margin-top:12px;
      padding:12px;
      border-radius:var(--radius2);
      border:1px solid var(--stroke-soft);
      background:rgba(8,14,28,.62);
    }

    .small{
      margin-top:10px;
      color:rgba(173,201,229,.67);
      font-size:12px;
      line-height:1.45;
    }
  </style>


</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="brand"><h1>Hunt Stats Tracker</h1><div class="subtitle">Paste a screenshot with <b>Ctrl+V</b> and get instant stats: <b>KD</b>, <b>KDA</b>, and recent trends.</div></div>
        <div class="subtitle">
          You only need kills, deaths, and assists visible. Analysis is automatic.
        </div>
      </div>
      <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-end;">
        <div class="pill">
          <span class="dot" id="dot"></span>
          <span id="status">Ready to analyze your screenshot</span>
        </div>

        <!-- Auth -->
        <div id="authBox" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
          <div id="userPill" class="pill" style="display:none; box-shadow:none; background:rgba(255,255,255,.05)">
            <span class="dot ok"></span>
            <span id="userLabel">Signed in</span>
            <button id="logoutBtn" style="padding:8px 10px; border-radius:10px;">Sign out</button>
          </div>

          <!-- Google button renders here -->
        <div id="googleBtn"></div>

        </div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="head">
          <div class="title">Upload Screenshot</div>
          <div class="pill" style="box-shadow:none;background:rgba(255,255,255,.05)">Paste your image</div>
        </div>
        <div class="body">
          <div class="drop" id="dropZone" tabindex="0">
            <div class="hint">
              Paste your screenshot with <b>Ctrl+V</b>.<br/>
              Or use <b>"Paste from clipboard"</b>.
            </div>

            <div class="actions">
              <button id="clearBtn">Clear</button>
              <button id="readBtn">Paste from clipboard</button>
              <button id="copyBtn" disabled>Copy result</button>
            </div>

            <div class="preview" id="previewBox" style="display:none">
              <img id="preview" alt="preview" />
            </div>

            <div class="small" id="debug">Status: waiting for image.</div>
          </div>
        </div>
      </section>

      <section class="card">
        <div class="head">
          <div class="title">Results</div>
          <div class="pill" style="box-shadow:none;background:rgba(255,255,255,.05)">Kills / Deaths / Assists</div>
        </div>
        <div class="body">
          <div class="kpis">
            <div class="kpi">
              <div class="label">KD</div>
              <div class="value" id="kdBig">-</div>
              <div class="sub" id="kdSub">-</div>
              <div class="badge"><span class="mini" id="kdMini"></span><span id="kdNext">-</span></div>

              <!-- NEW: progress to next 0.01 + safe -->
              <div class="meter">
                <div class="meterTop">
                  <span id="kdProgLabel">-</span>
                  <span><b id="kdSafe">-</b></span>
                </div>
                <div class="progress" aria-label="KD progress">
                  <div class="bar" id="kdBar"></div>
                </div>
              </div>
            </div>

            <div class="kpi">
              <div class="label">KDA</div>
              <div class="value" id="kdaBig">-</div>
              <div class="sub" id="kdaSub">-</div>
              <div class="badge"><span class="mini" id="kdaMini"></span><span id="kdaNext">-</span></div>

              <!-- NEW: progress to next 0.01 + safe -->
              <div class="meter">
                <div class="meterTop">
                  <span id="kdaProgLabel">-</span>
                  <span><b id="kdaSafe">-</b></span>
                </div>
                <div class="progress" aria-label="KDA progress">
                  <div class="bar" id="kdaBar"></div>
                </div>
              </div>
            </div>
          </div>

          <div style="height:12px"></div>

          <div class="kpi" style="min-height:auto;">
            <div class="label">Recent history</div>
            <div class="sub" id="histSub">Sign in to see your history.</div>
            <div class="chartsGrid">
              <div class="chartPanel">
                <div class="chartTitle">KDA</div>
                <div class="chartWrap">
                  <canvas id="chartKda"></canvas>
                </div>
              </div>
              <div class="chartPanel">
                <div class="chartTitle">KD</div>
                <div class="chartWrap">
                  <canvas id="chartKd"></canvas>
                </div>
              </div>
              <div class="chartPanel">
                <div class="chartTitle">Kills</div>
                <div class="chartWrap">
                  <canvas id="chartKills"></canvas>
                </div>
              </div>
              <div class="chartPanel chartWide">
                <div class="chartTitle">Deaths</div>
                <div class="chartWrap">
                  <canvas id="chartDeaths"></canvas>
                </div>
              </div>
              <div class="chartPanel">
                <div class="chartTitle">Assists</div>
                <div class="chartWrap">
                  <canvas id="chartAssists"></canvas>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    const statusEl = document.getElementById('status');
    const dotEl = document.getElementById('dot');

    const previewBox = document.getElementById('previewBox');
    const previewEl = document.getElementById('preview');

    const kdBig = document.getElementById('kdBig');
    const kdSub = document.getElementById('kdSub');
    const kdNext = document.getElementById('kdNext');
    const kdMini = document.getElementById('kdMini');
    const kdProgLabel = document.getElementById('kdProgLabel');
    const kdBar = document.getElementById('kdBar');
    const kdSafe = document.getElementById('kdSafe');

    const kdaBig = document.getElementById('kdaBig');
    const kdaSub = document.getElementById('kdaSub');
    const kdaNext = document.getElementById('kdaNext');
    const kdaMini = document.getElementById('kdaMini');
    const kdaProgLabel = document.getElementById('kdaProgLabel');
    const kdaBar = document.getElementById('kdaBar');
    const kdaSafe = document.getElementById('kdaSafe');

    const clearBtn = document.getElementById('clearBtn');
    const readBtn = document.getElementById('readBtn');
    const copyBtn = document.getElementById('copyBtn');
    const dropZone = document.getElementById('dropZone');
    const debugEl = document.getElementById('debug');

    // === AUTH + BACKEND CONFIG ===
    const histSub = document.getElementById("histSub");

    let metricsCharts = {};
    let resultCopyText = "-";

    const GOOGLE_CLIENT_ID = "1068658646999-j72o9l8k0s0bkdu9iviss6o6p31p8mv4.apps.googleusercontent.com";
    const BACKEND_BASE_URL = "https://fastapi-production-bf29.up.railway.app"; // no trailing slash

    const userPill = document.getElementById("userPill");
    const userLabel = document.getElementById("userLabel");
    const logoutBtn = document.getElementById("logoutBtn");

    function authExpired(message = "Your session expired. Please sign in again.") {
      // 1) UX notice
      setState("bad", message);

      // 2) clear local token and show login button
      localStorage.removeItem("google_id_token");
      setAuthUI(false);

      // 3) optional: if GIS is available, disable auto-select
      try {
        if (window.google?.accounts?.id?.disableAutoSelect) {
          google.accounts.id.disableAutoSelect();
        }
      } catch (_) {}
    }

    function setAuthUI(isLoggedIn, labelText = "Signed in") {
      const btn = googleBtn; // container where Google button is rendered
      if (isLoggedIn) {
        if (btn) btn.style.display = "none";
        userPill.style.display = "inline-flex";
        userLabel.textContent = labelText;
      } else {
        if (btn) btn.style.display = "block";
        userPill.style.display = "none";
      }
    }

    function destroyMetricCharts() {
      Object.values(metricsCharts).forEach((chart) => {
        try { chart?.destroy(); } catch (_) {}
      });
      metricsCharts = {};
    }

    function chartOptions(shouldStartAtZero = false) {
      return {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: {
          legend: { display: false },
          tooltip: { intersect: false, mode: "index" },
        },
        interaction: { intersect: false, mode: "index" },
        scales: {
          x: {
            grid: { color: "rgba(106,181,255,.10)" },
            ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 8, color: "rgba(198,222,246,.78)" },
          },
          y: {
            beginAtZero: shouldStartAtZero,
            grid: { color: "rgba(106,181,255,.10)" },
            ticks: { color: "rgba(198,222,246,.78)" },
          },
        },
        elements: {
          line: { borderWidth: 2.2, tension: 0.24 },
          point: { radius: 2, hoverRadius: 4 },
        },
      };
    }

    function renderMetricCharts(readings) {
      const ordered = [...readings].sort(
        (a, b) => new Date(a.created_at) - new Date(b.created_at)
      );

      const labels = ordered.map((r) => {
        const d = new Date(r.created_at);
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        return `${dd}/${mm}`;
      });

      const chartConfig = [
        { id: "chartKda", label: "KDA", color: "#4ed5ff", data: ordered.map((r) => computeKDA(r)), startAtZero: false },
        { id: "chartKd", label: "KD", color: "#6d7bff", data: ordered.map((r) => computeKD(r)), startAtZero: false },
        { id: "chartKills", label: "Kills", color: "#4be39d", data: ordered.map((r) => r.kills ?? 0), startAtZero: true },
        { id: "chartDeaths", label: "Deaths", color: "#ff5f85", data: ordered.map((r) => r.deaths ?? 0), startAtZero: true },
        { id: "chartAssists", label: "Assists", color: "#ffd166", data: ordered.map((r) => r.assists ?? 0), startAtZero: true },
      ];

      destroyMetricCharts();

      chartConfig.forEach((cfg) => {
        const canvas = document.getElementById(cfg.id);
        if (!canvas) return;

        metricsCharts[cfg.id] = new Chart(canvas.getContext("2d"), {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: cfg.label,
                data: cfg.data,
                borderColor: cfg.color,
                backgroundColor: `${cfg.color}33`,
                fill: true,
                spanGaps: true,
              },
            ],
          },
          options: chartOptions(cfg.startAtZero),
        });
      });
    }



    let lastPostKey = null;
    let lastPostAt = 0;

    function shouldPost(kills, deaths, assists) {
      const key = `${kills}|${deaths}|${assists}`;
      const now = Date.now();

      // Ignore duplicate payloads sent within 1500ms
      if (key === lastPostKey && (now - lastPostAt) < 1500) return false;

      lastPostKey = key;
      lastPostAt = now;
      return true;
    }

    async function postReadingIfLoggedIn(kills, deaths, assists) {
      const token = localStorage.getItem("google_id_token");
      if (!token) return; // no logueado => no postea

      try {
        const res = await fetch(`${BACKEND_BASE_URL}/readings`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
          },
          body: JSON.stringify({ kills, deaths, assists }),
        });

        if (!res.ok) {
          //  Si el backend dice 401 => token vencido/invalid
          if (res.status === 401) {
            authExpired("Session expired. Sign in again to save matches.");
            return;
          }

          const err = await res.json().catch(() => ({}));
          console.warn("API error:", res.status, err);
          return;
        }

        console.log("Reading guardado OK");
      } catch (e) {
        console.warn("Could not reach backend:", e);
      }
    }




    function setState(state, msg){
      statusEl.textContent = msg;
      dotEl.classList.remove('ok','bad');
      if(state === 'ok') dotEl.classList.add('ok');
      else if(state === 'bad') dotEl.classList.add('bad');
    }

    function fmt(n, digits=3){
      if(!Number.isFinite(n)) return '-';
      const s = n.toFixed(digits);
      return s.replace(/\.?0+$/,'');
    }

    function clamp01(x){
      return Math.max(0, Math.min(1, x));
    }

    function buildResultCopyText({ kills, deaths, assists, kd, kdNextShown, kdNeeded, kdSafeDeaths, kda, kdaNextShown, kdaNeeded, kdaSafeDeaths }){
      return (
        `Kills: ${fmt(kills)}\n` +
        `Deaths: ${fmt(deaths)}\n` +
        `Assists: ${fmt(assists)}\n\n` +
        `KD: ${fmt(kd,3)}\n` +
        `To reach ${fmt(kdNextShown,2)}: ${kdNeeded} more kills needed\n` +
        `Current buffer: ${kdSafeDeaths === Infinity ? 'INF' : kdSafeDeaths} deaths\n\n` +
        `KDA: ${fmt(kda,3)}\n` +
        `To reach ${fmt(kdaNextShown,2)}: ${kdaNeeded} more kills needed\n` +
        `Current buffer: ${kdaSafeDeaths === Infinity ? 'INF' : kdaSafeDeaths} deaths`
      );
    }

    // Google callback (GIS)
    function handleCredentialResponse(response) {
      localStorage.setItem("google_id_token", response.credential);
      setAuthUI(true, "Signed in [OK]");
      refreshHistoryIfLoggedIn();
      focusDropZone(); // keep paste target focused

    }
    window.handleCredentialResponse = handleCredentialResponse;

    const googleBtn = document.getElementById("googleBtn");

    

    // Init Google button (imperative, no race condition)
    function initGoogleLogin() {
      if (!window.google || !google.accounts || !google.accounts.id) {
        // Script may still be loading (async/defer)
        setTimeout(initGoogleLogin, 50);
        return;
      }

      google.accounts.id.initialize({
        client_id: GOOGLE_CLIENT_ID,
        callback: handleCredentialResponse,
      });

      google.accounts.id.renderButton(googleBtn, {
        theme: "outline",
        size: "large",
        text: "signin_with",
        shape: "rectangular",
      });

      const token = localStorage.getItem("google_id_token");
      setAuthUI(!!token, token ? "Signed in [OK]" : "-");
      if (token) refreshHistoryIfLoggedIn();
    }

    window.addEventListener("load", initGoogleLogin);
  
    logoutBtn?.addEventListener("click", () => {
      localStorage.removeItem("google_id_token");
      setAuthUI(false);
      if (histSub) histSub.textContent = "Sign in to see your history.";
      destroyMetricCharts();
    });

    function computeKD(r) {
      return r.deaths === 0 ? null : (r.kills / r.deaths);
    }
    function computeKDA(r) {
      return r.deaths === 0 ? null : ((r.kills + r.assists) / r.deaths);
    }
    let meInFlight = false;
    let meAbort = null;
    let lastMeFetchAt = 0;
    const ME_MIN_INTERVAL_MS = 1200; // 1.2s throttle

    async function fetchMyReadings() {
      const token = localStorage.getItem("google_id_token");
      if (!token) return null;

      // Abort previous request if still running
      if (meAbort) {
        try { meAbort.abort(); } catch {}
      }
      meAbort = new AbortController();

      const res = await fetch(`${BACKEND_BASE_URL}/me`, {
        headers: { "Authorization": `Bearer ${token}` },
        signal: meAbort.signal,
      });

      if (res.status === 401) {
        authExpired("Session expired. Sign in again to view your history.");
        return;
      }

      if (!res.ok) {
        const err = await res.text().catch(() => "");
        console.warn("GET /me failed:", res.status, err);
        return null;
      }
      return await res.json();
    }


    async function refreshHistoryIfLoggedIn() {
      const token = localStorage.getItem("google_id_token");
      if (!token) return;

      // lock: if one request is running, skip
      if (meInFlight) return;

      // throttle: avoid frequent repeated calls
      const now = Date.now();
      if (now - lastMeFetchAt < ME_MIN_INTERVAL_MS) return;
      lastMeFetchAt = now;

      meInFlight = true;
      try {
        const payload = await fetchMyReadings();

        if (!payload || !payload.readings) {
          if (histSub) histSub.textContent = "Sign in to see your history.";
          return;
        }
        

        const count = payload.readings.length;
        if (histSub) {
          histSub.textContent = count
            ? `Showing ${Math.min(20, count)} matches (oldest to newest).`
            : "No saved matches yet.";
        }

        if (count) renderMetricCharts(payload.readings);
        else destroyMetricCharts();
      } catch (e) {
        // AbortError is expected when cancelling a previous request
        if (String(e?.name) !== "AbortError") console.warn("refreshHistory error:", e);
      } finally {
        meInFlight = false;
      }
    }



    function reset(){
      resultCopyText = "-";
      previewBox.style.display = 'none';
      previewEl.src = '';

      kdBig.textContent = '-';
      kdSub.textContent = '-';
      kdNext.textContent = '-';
      kdProgLabel.textContent = '-';
      kdBar.style.width = '0%';
      kdSafe.textContent = '-';
      kdMini.classList.remove('ok','bad');

      kdaBig.textContent = '-';
      kdaSub.textContent = '-';
      kdaNext.textContent = '-';
      kdaProgLabel.textContent = '-';
      kdaBar.style.width = '0%';
      kdaSafe.textContent = '-';
      kdaMini.classList.remove('ok','bad');

      copyBtn.disabled = true;
      debugEl.textContent = 'Status: waiting for image.';
      setState('idle','Ready to analyze your screenshot');
    }

    clearBtn.addEventListener('click', reset);

    // IMPORTANT: keep focus so Ctrl+V paste lands here
    dropZone.addEventListener('click', () => dropZone.focus());
    window.addEventListener('load', () => dropZone.focus());

    // Restore focus when returning to the tab
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) focusDropZone();
    });

    // Restore focus when clicking outside inputs/buttons
    document.addEventListener('click', (e) => {
      const tag = (e.target?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || tag === "button") return;
      focusDropZone();
    }, true);

    copyBtn.addEventListener('click', async () => {
      try{
        await navigator.clipboard.writeText(resultCopyText);
        setState('ok','Result copied [OK]');
        setTimeout(() => setState('ok','Done [OK]'), 900);
      }catch(e){
        setState('bad','Could not copy result.');
      }
    });

    /**
     * Stats to the next +0.01 step and safe-death buffer:
     * how many extra deaths you can take without dropping the displayed value.
     *
     * - ratio = numerator / denominator
     * - displayed = floor(ratio*100)/100
     * - next = displayed + 0.01
     * - neededKills = ceil(next*denominator - numerator)
     * - progress = (numerator - base*denominator) / (next*denominator - base*denominator)
     * - safeDeaths = floor(numerator/displayed - denominator)
     */
    
    // Round to 2 decimals (half-up). Example: 1.965 -> 1.97
    function round2(x){
      // Epsilon mitigates binary floating-point edge cases (1.005, 1.965, etc.)
      return Math.round((x + 1e-12) * 100) / 100;
    }

    /**
     * Stats toward next +0.01 based on DISPLAYED value (2 decimals, half-up).
     *
     * For displayed value to increase by +0.01:
     *   ratio must be >= (nextShown - 0.005)
     *
     * "Safe by X" = extra deaths allowed without lowering displayed value,
     * while keeping ratio >= (shown - 0.005).
     */
    function hundredthStats(numerator, denominator){
      if(denominator <= 0){
        return {
          ratio: Infinity,
          shown: Infinity,
          nextShown: Infinity,
          needed: 0,
          progress: 1,
          safeDeaths: Infinity,
          note: 'Deaths=0 -> infinite'
        };
      }

      const ratio = numerator / denominator;

      // Displayed value (2 decimals, half-up rounding)
      const shown = round2(ratio);
      const nextShown = round2(shown + 0.01);

      const halfStep = 0.005;

      // Real (unrounded) thresholds for the displayed value:
      // shown if ratio >= shown - 0.005 (and < shown + 0.005)
      const startRatio = Math.max(0, shown - halfStep);
      // to display nextShown, ratio >= nextShown - 0.005 is enough
      const nextRatio = Math.max(0, nextShown - halfStep);

      // Kills needed to cross next displayed hundredth threshold
      const needed = Math.max(0, Math.ceil(nextRatio * denominator - numerator - 1e-12));

      // Progress from shown lower bound to nextShown lower bound
      const rangeStart = startRatio * denominator;
      const rangeEnd = nextRatio * denominator;
      const denomRange = (rangeEnd - rangeStart) || 1;
      const progress = clamp01((numerator - rangeStart) / denomRange);

      // Safe deaths: max d such that round2(numerator/(denominator+d)) >= shown
      // Sufficient condition: numerator/(den+d) >= shown - 0.005
      let safeDeaths = 0;
      const keepRatio = Math.max(0, shown - halfStep);
      if(shown <= 0 || keepRatio <= 0){
        safeDeaths = Infinity;
      }else{
        safeDeaths = Math.max(0, Math.floor((numerator / keepRatio) - denominator + 1e-12));
      }

      return { ratio, shown, nextShown, needed, progress, safeDeaths, note: null };
    }


      

    

    function setMiniState(el, ok){
      el.classList.remove('ok','bad');
      el.classList.add(ok ? 'ok' : 'bad');
    }

    async function handleImageFile(file, sourceLabel){
      // preview
      previewEl.src = URL.createObjectURL(file);
      previewBox.style.display = 'block';

      setState('idle', `Analyzing screenshot (${sourceLabel})...`);

      try{
        const res = await Tesseract.recognize(file, 'eng');
        const text = res?.data?.text ?? '';

        const matches = (text.match(/-?\d+(?:[.,]\d+)?/g) || []).map(s => s.replace(',', '.'));

        if(matches.length < 3){
          resultCopyText = 'Could not read data from the screenshot.';
          setState('bad','Could not read the data.');
          return;
        }

        const n1 = parseFloat(matches[0]); // kills
        const n2 = parseFloat(matches[1]); // deaths
        const n3 = parseFloat(matches[2]); // assists

        if(!Number.isFinite(n1) || !Number.isFinite(n2) || !Number.isFinite(n3)){
          resultCopyText = 'The screenshot does not contain valid data.';
          setState('bad','The screenshot does not contain valid data.');
          return;
        }

        postReadingIfLoggedIn(Math.trunc(n1), Math.trunc(n2), Math.trunc(n3));

        const kdNum = n1;
        const kdDen = n2;
        const kdaNum = (n1 + n3);
        const kdaDen = n2;

        const kd = (kdDen === 0) ? Infinity : (kdNum / kdDen);
        const kda = (kdaDen === 0) ? Infinity : (kdaNum / kdaDen);

        const kdS = hundredthStats(kdNum, kdDen);
        const kdaS = hundredthStats(kdaNum, kdaDen);

        // Big KPIs
        kdBig.textContent = Number.isFinite(kd) ? fmt(kd, 3) : 'INF';
        kdSub.textContent = `Kills ${fmt(n1)} / Deaths ${fmt(n2)}`;

        kdaBig.textContent = Number.isFinite(kda) ? fmt(kda, 3) : 'INF';
        kdaSub.textContent = `Kills ${fmt(n1)} + Assists ${fmt(n3)} / Deaths ${fmt(n2)}`;

        // Next 0.01 text
        kdNext.textContent = (Number.isFinite(kdS.nextShown))
          ? `To reach ${fmt(kdS.nextShown, 2)}: ${kdS.needed} more kills needed`
          : (kdS.note || '-');

        kdaNext.textContent = (Number.isFinite(kdaS.nextShown))
          ? `To reach ${fmt(kdaS.nextShown, 2)}: ${kdaS.needed} more kills needed`
          : (kdaS.note || '-');

        // Progress bars
        kdBar.style.width = `${Math.round(kdS.progress * 100)}%`;
        kdaBar.style.width = `${Math.round(kdaS.progress * 100)}%`;

        kdProgLabel.textContent = Number.isFinite(kdS.shown)
          ? `Progress to ${fmt(kdS.nextShown,2)}: ${Math.round(kdS.progress*100)}%`
          : 'Progress: -';

        kdaProgLabel.textContent = Number.isFinite(kdaS.shown)
          ? `Progress to ${fmt(kdaS.nextShown,2)}: ${Math.round(kdaS.progress*100)}%`
          : 'Progress: -';

        // Safe indicators
        kdSafe.textContent = (kdS.safeDeaths === Infinity) ? 'Current buffer: INF' : `Current buffer: ${kdS.safeDeaths} deaths without descending.`;
        kdaSafe.textContent = (kdaS.safeDeaths === Infinity) ? 'Current buffer: INF' : `Current buffer: ${kdaS.safeDeaths} deaths without descending.`;

        // Mini dot color: green if close to next threshold
        setMiniState(kdMini, kdS.needed === 0 || kdS.progress >= 0.5);
        setMiniState(kdaMini, kdaS.needed === 0 || kdaS.progress >= 0.5);

        resultCopyText = buildResultCopyText({
          kills: n1,
          deaths: n2,
          assists: n3,
          kd,
          kdNextShown: kdS.nextShown,
          kdNeeded: kdS.needed,
          kdSafeDeaths: kdS.safeDeaths,
          kda,
          kdaNextShown: kdaS.nextShown,
          kdaNeeded: kdaS.needed,
          kdaSafeDeaths: kdaS.safeDeaths,
        });

        copyBtn.disabled = false;
        setState('ok','Analysis complete [OK]');
      }catch(err){
        resultCopyText = 'Could not analyze the image.';
        setState('bad','Could not analyze the image.');
      }
    }

    function describeClipboardItems(items){
      debugEl.textContent = `Status: ${items.length} clipboard item(s) detected.`;
    }

    // Robust paste handler
    async function onPaste(event){
      event.preventDefault();
      event.stopPropagation();
      const cd = event.clipboardData;
      if(!cd){
        debugEl.textContent = 'Status: clipboard is not accessible from this event.';
        setState('bad','Could not read clipboard.');
        return;
      }

      describeClipboardItems(cd.items);

      const imgItem = [...cd.items].find(i => i.type && i.type.startsWith('image/'));
      if(!imgItem){
        setState('bad','Pasted content is not a valid image.');
        return;
      }

      const file = imgItem.getAsFile();
      if(!file){
        setState('bad','Could not convert clipboard item to File.');
        return;
      }

      await handleImageFile(file, 'paste');
    }

    function focusDropZone(){
      // Small delay to avoid iframe/repaint timing issues
      setTimeout(() => {
        try { dropZone.focus(); } catch {}
      }, 0);
    }

    // Listen in capture phase so paste is not swallowed.
    window.addEventListener('paste', onPaste, true);

    // Fallback: read via clipboard API (requires HTTPS/localhost and permission)
    readBtn.addEventListener('click', async () => {
      try{
        if(!navigator.clipboard || !navigator.clipboard.read){
          setState('bad','This browser does not allow image paste from that button.');
          debugEl.textContent = 'Status: this feature is not available in this browser.';
          return;
        }
        setState('idle','Reading clipboard...');

        const items = await navigator.clipboard.read();
        debugEl.textContent = `Status: ${items.length} clipboard item(s) read.`;

        // Find the first image/* clipboard item
        for(const item of items){
          const imgType = item.types.find(t => t.startsWith('image/'));
          if(imgType){
            const blob = await item.getType(imgType);
            const file = new File([blob], `clipboard.${imgType.split('/')[1] || 'png'}`, { type: imgType });
            await handleImageFile(file, 'clipboard.read()');
            return;
          }
        }

        setState('bad','No image found in clipboard.');
      }catch(e){
        setState('bad','Could not read clipboard. Check browser permissions.');
        debugEl.textContent = `Status: ${e?.message || e}`;
      }
    });

    reset();
  </script>
</body>
</html>







